<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>編集画面 - BloSke</title>
    
    <!-- アイコン設定 -->
    <link rel="icon" href="favicon.ico" sizes="any">
    <link rel="icon" href="icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">

    <!-- 共通スタイル -->
    <link rel="stylesheet" href="common.css">

    <!-- Firebase SDK (common.js より先に読み込む) -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>

    <!-- このページ専用のスタイル -->
    <style>
        /* (common.css で定義済み) */
        
        /* Canvasのカーソル制御 */
        #timetableCanvas {
            cursor: default;
        }
        #timetableCanvas.edit-mode-active {
            cursor: pointer; /* 編集モード時はポインター */
        }
        #timetableCanvas.dragging {
            cursor: grab; /* ドラッグ可能 */
        }
        #timetableCanvas.dragging:active {
            cursor: grabbing; /* 掴んでいる最中 */
        }
    </style>
</head>
<body>

    <main>
        <div id="edit-container">
            <!-- プロジェクト名 (仕様書 3.2.2) -->
            <h2 id="project-title" class="project-title" title="クリックして編集">my project</h2>

            <!-- ボタンフィールド (仕様書 3.2.2) -->
            <div class="button-field">
                <button id="add-block-btn" class="btn btn-primary"><i class="fa-solid fa-plus"></i> ブロック追加</button>
                <button id="edit-mode-btn" class="btn btn-secondary"><i class="fa-solid fa-pen"></i> 編集モード</button>
                <!-- 縦横表示は今回の実装範囲外のため無効化 -->
                <button id="toggle-view-btn" class="btn btn-secondary" disabled><i class="fa-solid fa-arrows-left-right"></i> 縦横表示</button>
                <button id="save-btn" class="btn btn-secondary"><i class="fa-solid fa-save"></i> 保存</button>
                <button id="export-img-btn" class="btn btn-secondary"><i class="fa-solid fa-image"></i> 画像出力</button>
                <button id="reset-btn" class="btn btn-secondary" style="color: #dc3545;"><i class="fa-solid fa-trash"></i> リセット</button>
            </div>

            <!-- タイムテーブルフィールド (Canvas) (仕様書 3.2.2) -->
            <div id="timetable-canvas-container">
                <canvas id="timetableCanvas" width="1000" height="400">
                    お使いのブラウザはCanvasに対応していません。
                </canvas>
            </div>
            
            <!-- オプション (仕様書 3.2.2) -->
            <div class="canvas-options">
                <input type="checkbox" id="two-column-toggle" disabled>
                <label for="two-column-toggle" style="color: #aaa;">2段組 (未実装)</label>
            </div>
        </div>
    </main>

    <!-- ブロック情報編集ウィンドウ (モーダル) (仕様書 3.2.2) -->
    <div id="block-edit-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="block-modal-title" class="modal-title">ブロック情報</h2>
            <form id="block-edit-form">
                <!-- 編集時に使用 -->
                <input type="hidden" id="block-id"> 
                
                <div class="form-group">
                    <label for="block-name">ブロック名</label>
                    <input type="text" id="block-name" class="form-input" required>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <div class="form-group" style="flex: 2;">
                        <label for="block-start-date">開始日</label>
                        <input type="date" id="block-start-date" class="form-input" required>
                    </div>
                    <div class="form-group" style="flex: 1;">
                        <label for="block-start-time">開始時刻</label>
                        <input type="time" id="block-start-time" class="form-input" required>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <div class="form-group" style="flex: 2;">
                        <label for="block-end-date">終了日</label>
                        <input type="date" id="block-end-date" class="form-input" required>
                    </div>
                    <div class="form-group" style="flex: 1;">
                        <label for="block-end-time">終了時刻</label>
                        <input type="time" id="block-end-time" class="form-input" required>
                    </div>
                </div>

                <div class="form-group">
                    <label>カラー</label>
                    <div id="color-picker" style="display: flex; justify-content: space-around; padding: 10px 0;">
                        <!-- JSで動的に生成 -->
                    </div>
                    <input type="hidden" id="block-color" value="#3B82F6">
                </div>

                <div class="modal-actions">
                    <button type="button" id="cancel-block-edit-btn" class="btn btn-secondary">キャンセル</button>
                    <button type="submit" class="btn btn-primary">決定</button>
                </div>
            </form>
        </div>
    </div>

    <!-- 共通スクリプト -->
    <script src="common.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // 共通UIを初期化
            initCommonUI('BloSke');

            // --- グローバル変数・定数 ---
            const projectNameEl = document.getElementById('project-title');
            const canvasContainer = document.getElementById('timetable-canvas-container');
            const canvas = document.getElementById('timetableCanvas');
            const ctx = canvas.getContext('2d');
            
            const H_PADDING = 80; // 時刻表示用の左右パディング
            const V_PADDING = 50; // 上部パディング
            const ROW_HEIGHT = 60; // 各行の高さ
            const DELETE_BTN_SIZE = 20; // 削除ボタンのサイズ
            const FONT_S = '12px sans-serif';
            const FONT_M = '14px sans-serif';
            const FONT_L = 'bold 14px sans-serif';
            
            let projectBlocks = []; // {id, name, startISO, endISO, color, layoutRow, hitBox, deleteHitBox}
            let currentProjectName = '新規プロジェクト';
            let isEditMode = false;
            let editingBlockId = null; 

            // Canvas描画用の計算済みプロパティ
            let minTimeMs = 0; 
            let maxTimeMs = 0; 
            let totalDurationMs = 0; 
            let pxPerMs = 0; 
            let layoutRowCount = 0; 

            // ドラッグ＆ドロップ用
            let isDragging = false;
            let dragTargetBlock = null;
            let dragStartX = 0;
            let dragOriginalStartMs = 0;
            let dragOriginalEndMs = 0;

            // --- 1. データ読み込み・初期化 ---

            function parseCsvData(csvData) {
                const lines = csvData.trim().split('\n');
                const blocks = [];
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i];
                    const parts = line.split(',').map(part => part.trim().replace(/"/g, ''));
                    if (parts.length >= 4) {
                        blocks.push({
                            id: Date.now().toString() + i,
                            name: parts[0],
                            startISO: parts[1],
                            endISO: parts[2],
                            color: parts[3]
                        });
                    }
                }
                return blocks;
            }

            function loadFromLocalStorage() {
                try {
                    const dataStr = localStorage.getItem('bloske_local_project');
                    if (!dataStr) return;
                    
                    const data = JSON.parse(dataStr);
                    currentProjectName = data.name || '復元プロジェクト';
                    projectBlocks = data.blocks || [];
                } catch (e) {
                    console.error('ローカルストレージの復元に失敗:', e);
                    localStorage.removeItem('bloske_local_project');
                }
            }
            
            function saveToLocalStorage() {
                const data = {
                    name: currentProjectName,
                    blocks: projectBlocks
                };
                localStorage.setItem('bloske_local_project', JSON.stringify(data));
            }

            // --- 2. Canvas描画ロジック ---

            function updateTimelineBounds() {
                if (projectBlocks.length === 0) {
                    const now = new Date();
                    minTimeMs = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours()).getTime(); 
                    maxTimeMs = minTimeMs + (4 * 60 * 60 * 1000); 
                    return;
                }

                let minStart = Infinity;
                let maxEnd = -Infinity;

                projectBlocks.forEach(block => {
                    const start = new Date(block.startISO).getTime();
                    const end = new Date(block.endISO).getTime();
                    if (start < minStart) minStart = start;
                    if (end > maxEnd) maxEnd = end;
                });

                const roundDownTo30Min = (ms) => {
                    const d = new Date(ms);
                    const minutes = d.getMinutes();
                    if (minutes >= 30) d.setMinutes(30, 0, 0);
                    else d.setMinutes(0, 0, 0);
                    return d.getTime();
                };
                
                const roundUpTo30Min = (ms) => {
                    const d = new Date(ms);
                    const minutes = d.getMinutes();
                    if (minutes > 30) d.setHours(d.getHours() + 1, 0, 0, 0);
                    else if (minutes > 0) d.setMinutes(30, 0, 0);
                    return d.getTime();
                };

                minTimeMs = roundDownTo30Min(minStart);
                maxTimeMs = roundUpTo30Min(maxEnd);
                
                if (maxTimeMs - minTimeMs < (60 * 60 * 1000)) { 
                    maxTimeMs = minTimeMs + (60 * 60 * 1000); 
                }
            }

            function calculateBlockLayout() {
                // ドラッグ中のブロックは、一時的に更新された時刻でソート・配置される
                const sortedBlocks = [...projectBlocks].sort((a, b) => new Date(a.startISO).getTime() - new Date(b.startISO).getTime());
                
                const rows = []; 
                layoutRowCount = 0;

                for (const block of sortedBlocks) {
                    const blockStart = new Date(block.startISO).getTime();
                    let placed = false;

                    for (let i = 0; i < rows.length; i++) {
                        if (blockStart >= rows[i]) { 
                            rows[i] = new Date(block.endISO).getTime(); 
                            block.layoutRow = i; 
                            placed = true;
                            break;
                        }
                    }

                    if (!placed) {
                        rows.push(new Date(block.endISO).getTime());
                        block.layoutRow = rows.length - 1;
                    }
                }
                layoutRowCount = rows.length;
            }

            function timeToX(ms) {
                return H_PADDING + (ms - minTimeMs) * pxPerMs;
            }
            
            function formatTime(date) {
                return date.toTimeString().substring(0, 5);
            }

            function drawCanvas() {
                updateTimelineBounds();
                calculateBlockLayout();

                totalDurationMs = maxTimeMs - minTimeMs;
                const minCanvasWidth = canvasContainer.clientWidth;
                
                const calculatedWidth = totalDurationMs * (800 / (4 * 60 * 60 * 1000)); 
                
                const canvasWidth = Math.max(minCanvasWidth, calculatedWidth) + H_PADDING * 2;
                const canvasHeight = Math.max(400, (layoutRowCount * ROW_HEIGHT) + V_PADDING * 2);

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                pxPerMs = (canvas.width - H_PADDING * 2) / totalDurationMs;

                // 背景を白で塗りつぶす (画像出力のため)
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (projectBlocks.length === 0) {
                    ctx.fillStyle = '#adb5bd';
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('イベントが1つも登録されていません。', canvas.width / 2, canvas.height / 2);
                    return;
                }

                // 時間軸
                const FOUR_HOURS_MS = 4 * 60 * 60 * 1000;
                const stepMs = (totalDurationMs <= FOUR_HOURS_MS) ? (30 * 60 * 1000) : (60 * 60 * 1000); 
                
                ctx.strokeStyle = '#e9ecef'; 
                ctx.fillStyle = '#868e96'; 
                ctx.font = FONT_S;
                ctx.textAlign = 'center';

                for (let t = minTimeMs; t <= maxTimeMs; t += stepMs) {
                    // 両端はスキップ (太線で描画するため)
                    if (t === minTimeMs || t === maxTimeMs) continue;

                    const x = timeToX(t);
                    ctx.beginPath();
                    ctx.moveTo(x, V_PADDING - 10);
                    ctx.lineTo(x, canvas.height - (V_PADDING / 2));
                    ctx.stroke();
                    
                    ctx.fillText(formatTime(new Date(t)), x, V_PADDING - 15);
                }

                // 左右の太線
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.fillStyle = '#333';
                ctx.font = FONT_L;
                
                const minDate = new Date(minTimeMs);
                const maxDate = new Date(maxTimeMs);
                
                const xStart = timeToX(minTimeMs);
                ctx.beginPath();
                ctx.moveTo(xStart, V_PADDING - 20);
                ctx.lineTo(xStart, canvas.height - (V_PADDING / 2));
                ctx.stroke();
                ctx.fillText(formatTime(minDate), xStart, V_PADDING - 25);
                
                const xEnd = timeToX(maxTimeMs);
                ctx.beginPath();
                ctx.moveTo(xEnd, V_PADDING - 20);
                ctx.lineTo(xEnd, canvas.height - (V_PADDING / 2));
                ctx.stroke();
                ctx.fillText(formatTime(maxDate), xEnd, V_PADDING - 25);
                
                if (minDate.toDateString() !== maxDate.toDateString()) {
                    ctx.font = FONT_S;
                    ctx.fillText(minDate.toLocaleDateString('ja-JP'), xStart, V_PADDING - 40);
                    ctx.fillText(maxDate.toLocaleDateString('ja-JP'), xEnd, V_PADDING - 40);
                }

                // ブロックの描画
                projectBlocks.forEach(block => {
                    const start = new Date(block.startISO);
                    const end = new Date(block.endISO);
                    
                    const x = timeToX(start.getTime());
                    const y = V_PADDING + (block.layoutRow * ROW_HEIGHT);
                    const width = (end.getTime() - start.getTime()) * pxPerMs;
                    const height = ROW_HEIGHT * 0.8; 

                    ctx.fillStyle = block.color;
                    
                    // ドラッグ中のブロックは少し透明に
                    if (isDragging && dragTargetBlock === block) {
                        ctx.globalAlpha = 0.6;
                    }
                    
                    // 角丸矩形
                    roundRect(ctx, x, y, width, height, 5, true, false);
                    
                    ctx.globalAlpha = 1.0; // 戻す

                    ctx.fillStyle = '#ffffff'; 
                    ctx.font = FONT_L;
                    ctx.textAlign = 'left';
                    // 幅が狭い場合はテキストを省略または非表示にする処理を入れると良いが、今回は簡易的にクリップ
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(x, y, width, height);
                    ctx.clip();
                    
                    ctx.fillText(block.name, x + 8, y + 20);
                    ctx.font = FONT_S;
                    ctx.fillText(formatTime(start), x + 8, y + 38);
                    ctx.textAlign = 'right';
                    ctx.fillText(formatTime(end), x + width - 8, y + 38);
                    ctx.restore();

                    block.hitBox = { x, y, width, height };

                    if (isEditMode) {
                        // 削除ボタン
                        const delX = x + width - DELETE_BTN_SIZE + 5;
                        const delY = y - 5;
                        
                        ctx.fillStyle = 'rgba(220, 53, 69, 1)'; 
                        ctx.beginPath();
                        ctx.arc(delX, delY, DELETE_BTN_SIZE / 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 12px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('×', delX, delY);
                        ctx.textBaseline = 'alphabetic'; // 戻す

                        block.deleteHitBox = { 
                            x: delX - DELETE_BTN_SIZE/2, 
                            y: delY - DELETE_BTN_SIZE/2, 
                            width: DELETE_BTN_SIZE, 
                            height: DELETE_BTN_SIZE 
                        };
                    } else {
                        block.deleteHitBox = null;
                    }
                });
            }
            
            // 角丸矩形描画ヘルパー
            function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
                if (typeof stroke === 'undefined') { stroke = true; }
                if (typeof radius === 'undefined') { radius = 5; }
                if (typeof radius === 'number') { radius = {tl: radius, tr: radius, br: radius, bl: radius}; } else { var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0}; for (var side in defaultRadius) { radius[side] = radius[side] || defaultRadius[side]; } }
                ctx.beginPath();
                ctx.moveTo(x + radius.tl, y);
                ctx.lineTo(x + width - radius.tr, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
                ctx.lineTo(x + width, y + height - radius.br);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
                ctx.lineTo(x + radius.bl, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
                ctx.lineTo(x, y + radius.tl);
                ctx.quadraticCurveTo(x, y, x + radius.tl, y);
                ctx.closePath();
                if (fill) { ctx.fill(); }
                if (stroke) { ctx.stroke(); }
            }

            // --- 3. イベントリスナー (ボタン) ---

            projectNameEl.addEventListener('click', () => {
                const newName = prompt('新しいプロジェクト名を入力してください:', currentProjectName);
                if (newName && newName.trim() !== '') {
                    currentProjectName = newName.trim();
                    projectNameEl.textContent = currentProjectName;
                    saveToLocalStorage(); 
                }
            });

            document.getElementById('add-block-btn').addEventListener('click', () => {
                editingBlockId = null; 
                document.getElementById('block-modal-title').textContent = 'ブロック追加';
                document.getElementById('block-edit-form').reset();
                document.getElementById('block-id').value = '';
                
                const now = new Date();
                const yyyyMMdd = now.toISOString().split('T')[0];
                const hhMM = now.toTimeString().substring(0, 5);
                document.getElementById('block-start-date').value = yyyyMMdd;
                document.getElementById('block-start-time').value = hhMM;
                document.getElementById('block-end-date').value = yyyyMMdd;
                document.getElementById('block-end-time').value = hhMM;

                blockColorInput.value = colors[0];
                 Array.from(colorPicker.children).forEach((child, index) => {
                    child.style.borderColor = (index === 0) ? '#333' : 'transparent';
                });
                showModal('block-edit-modal');
            });
            
            document.getElementById('edit-mode-btn').addEventListener('click', (e) => {
                isEditMode = !isEditMode;
                const btn = e.currentTarget;
                if (isEditMode) {
                    btn.innerHTML = '<i class="fa-solid fa-check"></i> 編集モード終了';
                    btn.classList.add('btn-primary');
                    btn.classList.remove('btn-secondary');
                    canvas.classList.add('edit-mode-active');
                } else {
                    btn.innerHTML = '<i class="fa-solid fa-pen"></i> 編集モード';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                    canvas.classList.remove('edit-mode-active');
                }
                drawCanvas(); 
            });

            document.getElementById('reset-btn').addEventListener('click', () => {
                if (confirm('プロジェクトをリセットしますか？\n（すべてのブロックが削除されます）')) {
                    projectBlocks = [];
                    saveToLocalStorage();
                    drawCanvas();
                }
            });

            document.getElementById('save-btn').addEventListener('click', () => {
                const user = getUserSession();
                if (!user) {
                    alert('プロジェクトを保存するにはログインが必要です。');
                    sessionStorage.setItem('login_redirect_reason', 'save');
                    window.location.href = 'login.html';
                    return;
                }
                saveProjectData(user.username);
            });

            // ★★★ 追加: 画像出力機能 ★★★
            document.getElementById('export-img-btn').addEventListener('click', () => {
                if (projectBlocks.length === 0) {
                    alert('出力するブロックがありません。');
                    return;
                }
                
                try {
                    // Canvasを画像データURLに変換
                    const dataUrl = canvas.toDataURL('image/png');
                    
                    // ダウンロードリンクを作成してクリック
                    const link = document.createElement('a');
                    link.download = `${currentProjectName}.png`;
                    link.href = dataUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } catch (e) {
                    console.error('画像出力エラー:', e);
                    alert('画像の出力に失敗しました。');
                }
            });

            // --- 4. イベントリスナー (モーダル) ---

            setupModalClose('block-edit-modal', '#cancel-block-edit-btn');
            const blockEditForm = document.getElementById('block-edit-form');
            const colors = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', '#64748B'];
            const colorPicker = document.getElementById('color-picker');
            const blockColorInput = document.getElementById('block-color');

            colors.forEach(color => {
                const colorCircle = document.createElement('div');
                colorCircle.style.width = '30px';
                colorCircle.style.height = '30px';
                colorCircle.style.borderRadius = '50%';
                colorCircle.style.backgroundColor = color;
                colorCircle.style.cursor = 'pointer';
                colorCircle.style.border = '3px solid transparent';
                colorCircle.dataset.color = color;
                
                if (color === blockColorInput.value) {
                    colorCircle.style.borderColor = '#333';
                }

                colorCircle.addEventListener('click', () => {
                    blockColorInput.value = color;
                    Array.from(colorPicker.children).forEach(child => {
                        child.style.borderColor = 'transparent';
                    });
                    colorCircle.style.borderColor = '#333';
                });
                colorPicker.appendChild(colorCircle);
            });

            blockEditForm.addEventListener('submit', (e) => {
                e.preventDefault();
                
                const name = document.getElementById('block-name').value;
                const startDate = document.getElementById('block-start-date').value;
                const startTime = document.getElementById('block-start-time').value;
                const endDate = document.getElementById('block-end-date').value;
                const endTime = document.getElementById('block-end-time').value;
                const color = document.getElementById('block-color').value;

                if (!name || !startDate || !startTime || !endDate || !endTime) {
                    alert('すべての日時を入力してください。');
                    return;
                }
                
                const startISO = new Date(`${startDate}T${startTime}`).toISOString();
                const endISO = new Date(`${endDate}T${endTime}`).toISOString();

                if (new Date(endISO) <= new Date(startISO)) {
                    alert('終了日時は開始日時より後に設定してください。');
                    return;
                }

                const blockData = { name, startISO, endISO, color };

                if (editingBlockId) {
                    const index = projectBlocks.findIndex(b => b.id === editingBlockId);
                    if (index !== -1) {
                        projectBlocks[index] = { ...projectBlocks[index], ...blockData };
                    }
                } else {
                    projectBlocks.push({
                        ...blockData,
                        id: Date.now().toString()
                    });
                }
                
                editingBlockId = null; 
                saveToLocalStorage();
                drawCanvas();
                hideModal('block-edit-modal');
            });

            // --- 5. イベントリスナー (Canvas操作: 編集/削除/ドラッグ) ---

            function openEditModal(block) {
                editingBlockId = block.id; 
                document.getElementById('block-modal-title').textContent = 'ブロック編集';
                
                document.getElementById('block-id').value = block.id;
                document.getElementById('block-name').value = block.name;
                
                const start = new Date(block.startISO);
                const end = new Date(block.endISO);
                
                document.getElementById('block-start-date').value = start.toISOString().split('T')[0];
                document.getElementById('block-start-time').value = start.toTimeString().substring(0, 5);
                document.getElementById('block-end-date').value = end.toISOString().split('T')[0];
                document.getElementById('block-end-time').value = end.toTimeString().substring(0, 5);

                blockColorInput.value = block.color;
                Array.from(colorPicker.children).forEach(child => {
                    child.style.borderColor = (child.dataset.color === block.color) ? '#333' : 'transparent';
                });

                showModal('block-edit-modal');
            }

            // 共通: 座標取得
            function getCanvasCoordinates(e) {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                return {
                    x: clientX - rect.left + canvasContainer.scrollLeft,
                    y: clientY - rect.top + canvasContainer.scrollTop
                };
            }

            // --- マウスダウン / タッチスタート ---
            function handleInputStart(e) {
                if (isEditMode) {
                    // 編集モード中はドラッグさせず、クリック判定のみ
                    handleClickInEditMode(e);
                    return;
                }

                const pos = getCanvasCoordinates(e);
                
                // 手前のブロックから判定
                for (const block of [...projectBlocks].reverse()) {
                    if (!block.hitBox) continue;
                    const h = block.hitBox;
                    if (pos.x >= h.x && pos.x <= h.x + h.width && pos.y >= h.y && pos.y <= h.y + h.height) {
                        // ドラッグ開始
                        isDragging = true;
                        dragTargetBlock = block;
                        dragStartX = pos.x;
                        dragOriginalStartMs = new Date(block.startISO).getTime();
                        dragOriginalEndMs = new Date(block.endISO).getTime();
                        
                        canvas.classList.add('dragging');
                        // タッチスクロール防止 (ブロック上のみ)
                        if (e.type === 'touchstart') e.preventDefault(); 
                        break;
                    }
                }
            }

            // --- 編集モードでのクリック判定 ---
            function handleClickInEditMode(e) {
                const pos = getCanvasCoordinates(e);
                
                for (const block of [...projectBlocks].reverse()) {
                    if (!block.hitBox) continue;
                    
                    // 削除ボタン
                    const d = block.deleteHitBox;
                    if (d && pos.x >= d.x && pos.x <= d.x + d.width && pos.y >= d.y && pos.y <= d.y + d.height) {
                        if (confirm(`「${block.name}」を本当に削除しますか？`)) {
                            projectBlocks = projectBlocks.filter(b => b.id !== block.id);
                            saveToLocalStorage();
                            drawCanvas();
                        }
                        return;
                    }
                    
                    // 本体 (編集)
                    const h = block.hitBox;
                    if (pos.x >= h.x && pos.x <= h.x + h.width && pos.y >= h.y && pos.y <= h.y + h.height) {
                        openEditModal(block);
                        return;
                    }
                }
            }

            // --- マウスムーブ / タッチムーブ ---
            function handleInputMove(e) {
                if (!isDragging || !dragTargetBlock) return;
                
                e.preventDefault(); // スクロール防止
                const pos = getCanvasCoordinates(e);
                const deltaX = pos.x - dragStartX;
                
                // ピクセル差分を時間差分(ms)に変換
                const deltaMs = deltaX / pxPerMs;
                
                const newStartMs = dragOriginalStartMs + deltaMs;
                const newEndMs = dragOriginalEndMs + deltaMs;
                
                dragTargetBlock.startISO = new Date(newStartMs).toISOString();
                dragTargetBlock.endISO = new Date(newEndMs).toISOString();
                
                drawCanvas(); // リアルタイム再描画
            }

            // --- マウスアップ / タッチエンド ---
            function handleInputEnd(e) {
                if (isDragging) {
                    isDragging = false;
                    dragTargetBlock = null;
                    canvas.classList.remove('dragging');
                    saveToLocalStorage(); // 変更を保存
                }
            }

            // イベントリスナー登録
            canvas.addEventListener('mousedown', handleInputStart);
            canvas.addEventListener('mousemove', handleInputMove);
            canvas.addEventListener('mouseup', handleInputEnd);
            canvas.addEventListener('mouseleave', handleInputEnd);

            canvas.addEventListener('touchstart', handleInputStart, {passive: false});
            canvas.addEventListener('touchmove', handleInputMove, {passive: false});
            canvas.addEventListener('touchend', handleInputEnd);


            // --- 6. 最終初期化処理 ---

            const urlParams = new URLSearchParams(window.location.search);
            const loadedCsvData = sessionStorage.getItem('bloske_loaded_csv');
            
            if (loadedCsvData) {
                currentProjectName = sessionStorage.getItem('bloske_current_project_name') || '読み込みプロジェクト';
                projectBlocks = parseCsvData(loadedCsvData);
                sessionStorage.removeItem('bloske_loaded_csv'); 
                sessionStorage.removeItem('bloske_current_project_name');
            } else if (urlParams.has('restore')) {
                loadFromLocalStorage();
            } else {
                currentProjectName = sessionStorage.getItem('bloske_current_project_name') || '新規プロジェクト';
                sessionStorage.removeItem('bloske_current_project_name');
            }
            projectNameEl.textContent = currentProjectName;
            
            drawCanvas(); 
            window.addEventListener('resize', drawCanvas);

            async function saveProjectData(username) {
                const projectName = projectNameEl.textContent;
                
                let csvData = "ブロック名,開始日時ISO,終了日時ISO,カラーコード\n"; 
                projectBlocks.forEach(block => {
                    const name = `"${block.name.replace(/"/g, '""')}"`;
                    csvData += `${name},"${block.startISO}","${block.endISO}","${block.color}"\n`;
                });
                
                if (!confirm(`プロジェクト「${projectName}」を保存しますか？`)) {
                    return;
                }

                try {
                    await callGasApi('saveProject', {
                        username: username,
                        projectName: projectName,
                        csvData: csvData
                    });
                    alert('保存しました。');
                    localStorage.removeItem('bloske_local_project');
                } catch (error) {
                    console.error('保存失敗:', error);
                }
            }
        });
    </script>
</body>
</html>
