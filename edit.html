<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>編集画面 - BloSke</title>
    
    <!-- アイコン設定 -->
    <link rel="icon" href="favicon.ico" sizes="any">
    <link rel="icon" href="icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">

    <!-- 共通スタイル -->
    <link rel="stylesheet" href="common.css">

    <!-- Firebase SDK (common.js より先に読み込む) -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>

    <!-- このページ専用のスタイル -->
    <style>
        /* (common.css で定義済み) */
        
        /* Canvasのカーソル制御 */
        #timetableCanvas {
            cursor: default;
        }
        #timetableCanvas.edit-mode-active {
            cursor: pointer; /* 編集モード時はポインター */
        }
        #timetableCanvas.dragging {
            cursor: grab; /* ドラッグ可能 */
        }
        #timetableCanvas.dragging:active {
            cursor: grabbing; /* 掴んでいる最中 */
        }
    </style>
</head>
<body>

    <main>
        <div id="edit-container">
            <!-- プロジェクト名 (仕様書 3.2.2) -->
            <h2 id="project-title" class="project-title" title="クリックして編集">my project</h2>

            <!-- ボタンフィールド (仕様書 3.2.2) -->
            <div class="button-field">
                <button id="add-block-btn" class="btn btn-primary"><i class="fa-solid fa-plus"></i> ブロック追加</button>
                <button id="edit-mode-btn" class="btn btn-secondary"><i class="fa-solid fa-pen"></i> 編集モード</button>
                <!-- 縦横表示は今回の実装範囲外のため無効化 -->
                <button id="toggle-view-btn" class="btn btn-secondary" disabled><i class="fa-solid fa-arrows-left-right"></i> 縦横表示</button>
                <button id="save-btn" class="btn btn-secondary"><i class="fa-solid fa-save"></i> 保存</button>
                <button id="export-img-btn" class="btn btn-secondary"><i class="fa-solid fa-image"></i> 画像出力</button>
                <button id="reset-btn" class="btn btn-secondary" style="color: #dc3545;"><i class="fa-solid fa-trash"></i> リセット</button>
            </div>

            <!-- タイムテーブルフィールド (Canvas) (仕様書 3.2.2) -->
            <div id="timetable-canvas-container">
                <canvas id="timetableCanvas" width="1000" height="400">
                    お使いのブラウザはCanvasに対応していません。
                </canvas>
            </div>
            
            <!-- オプション (仕様書 3.2.2) -->
            <div class="canvas-options">
                <input type="checkbox" id="two-column-toggle" disabled>
                <label for="two-column-toggle" style="color: #aaa;">2段組 (未実装)</label>
            </div>
        </div>
    </main>

    <!-- ブロック情報編集ウィンドウ (モーダル) (仕様書 3.2.2) -->
    <div id="block-edit-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="block-modal-title" class="modal-title">ブロック情報</h2>
            <form id="block-edit-form">
                <!-- 編集時に使用 -->
                <input type="hidden" id="block-id"> 
                
                <div class="form-group">
                    <label for="block-name">ブロック名</label>
                    <input type="text" id="block-name" class="form-input" required>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <div class="form-group" style="flex: 2;">
                        <label for="block-start-date">開始日</label>
                        <input type="date" id="block-start-date" class="form-input" required>
                    </div>
                    <div class="form-group" style="flex: 1;">
                        <label for="block-start-time">開始時刻</label>
                        <input type="time" id="block-start-time" class="form-input" required>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <div class="form-group" style="flex: 2;">
                        <label for="block-end-date">終了日</label>
                        <input type="date" id="block-end-date" class="form-input" required>
                    </div>
                    <div class="form-group" style="flex: 1;">
                        <label for="block-end-time">終了時刻</label>
                        <input type="time" id="block-end-time" class="form-input" required>
                    </div>
                </div>

                <div class="form-group">
                    <label>カラー</label>
                    <div id="color-picker" style="display: flex; justify-content: space-around; padding: 10px 0;">
                        <!-- JSで動的に生成 -->
                    </div>
                    <input type="hidden" id="block-color" value="#3B82F6">
                </div>

                <div class="modal-actions">
                    <button type="button" id="cancel-block-edit-btn" class="btn btn-secondary">キャンセル</button>
                    <button type="submit" class="btn btn-primary">決定</button>
                </div>
            </form>
        </div>
    </div>

    <!-- 共通スクリプト -->
    <script src="common.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // 共通UIを初期化
            initCommonUI('BloSke');

            // --- グローバル変数・定数 ---
            const projectNameEl = document.getElementById('project-title');
            const canvasContainer = document.getElementById('timetable-canvas-container');
            const canvas = document.getElementById('timetableCanvas');
            const ctx = canvas.getContext('2d');
            
            const H_PADDING = 80; // 時刻表示用の左右パディング
            const V_PADDING = 50; // 上部パディング
            const ROW_HEIGHT = 60; // 各行の高さ
            const DELETE_BTN_SIZE = 20; // 削除ボタンのサイズ
            const HEADER_HEIGHT_EXPORT = 80; // 画像出力時のヘッダー高さ
            const FONT_S = '12px sans-serif';
            const FONT_M = '14px sans-serif';
            const FONT_L = 'bold 14px sans-serif';
            const FONT_TITLE = 'bold 24px sans-serif';
            
            let projectBlocks = []; 
            let currentProjectName = '新規プロジェクト';
            let isEditMode = false;
            let editingBlockId = null; 

            // Canvas描画用の計算済みプロパティ
            let minTimeMs = 0; 
            let maxTimeMs = 0; 
            let totalDurationMs = 0; 
            let pxPerMs = 0; 
            let layoutRowCount = 0; 

            // ドラッグ＆ドロップ用
            let isDragging = false;
            let dragTargetBlock = null;
            let dragStartX = 0;
            let dragOriginalStartMs = 0;
            let dragOriginalEndMs = 0;
            let dragOffsetY = 0; // マウスとブロック上端の差分
            let dragCurrentY = 0; // 現在のドラッグY位置

            // アプリロゴ画像 (出力用)
            const appIcon = new Image();
            appIcon.src = 'icon.svg';

            // --- 1. データ読み込み・初期化 ---

            function parseCsvData(csvData) {
                const lines = csvData.trim().split('\n');
                const blocks = [];
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i];
                    const parts = line.split(',').map(part => part.trim().replace(/"/g, ''));
                    if (parts.length >= 4) {
                        blocks.push({
                            id: Date.now().toString() + i,
                            name: parts[0],
                            startISO: parts[1],
                            endISO: parts[2],
                            color: parts[3]
                        });
                    }
                }
                return blocks;
            }

            function loadFromLocalStorage() {
                try {
                    const dataStr = localStorage.getItem('bloske_local_project');
                    if (!dataStr) return;
                    
                    const data = JSON.parse(dataStr);
                    currentProjectName = data.name || '復元プロジェクト';
                    projectBlocks = data.blocks || [];
                } catch (e) {
                    console.error('ローカルストレージの復元に失敗:', e);
                    localStorage.removeItem('bloske_local_project');
                }
            }
            
            function saveToLocalStorage() {
                const data = {
                    name: currentProjectName,
                    blocks: projectBlocks
                };
                localStorage.setItem('bloske_local_project', JSON.stringify(data));
            }

            // --- 2. Canvas描画ロジック ---

            function updateTimelineBounds() {
                if (projectBlocks.length === 0) {
                    const now = new Date();
                    minTimeMs = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours()).getTime(); 
                    maxTimeMs = minTimeMs + (4 * 60 * 60 * 1000); 
                    return;
                }

                let minStart = Infinity;
                let maxEnd = -Infinity;

                projectBlocks.forEach(block => {
                    const start = new Date(block.startISO).getTime();
                    const end = new Date(block.endISO).getTime();
                    if (start < minStart) minStart = start;
                    if (end > maxEnd) maxEnd = end;
                });

                const roundDownTo30Min = (ms) => {
                    const d = new Date(ms);
                    const minutes = d.getMinutes();
                    if (minutes >= 30) d.setMinutes(30, 0, 0);
                    else d.setMinutes(0, 0, 0);
                    return d.getTime();
                };
                
                const roundUpTo30Min = (ms) => {
                    const d = new Date(ms);
                    const minutes = d.getMinutes();
                    if (minutes > 30) d.setHours(d.getHours() + 1, 0, 0, 0);
                    else if (minutes > 0) d.setMinutes(30, 0, 0);
                    return d.getTime();
                };

                minTimeMs = roundDownTo30Min(minStart);
                maxTimeMs = roundUpTo30Min(maxEnd);
                
                if (maxTimeMs - minTimeMs < (60 * 60 * 1000)) { 
                    maxTimeMs = minTimeMs + (60 * 60 * 1000); 
                }
            }

            function calculateBlockLayout() {
                const sortedBlocks = [...projectBlocks].sort((a, b) => new Date(a.startISO).getTime() - new Date(b.startISO).getTime());
                
                const rows = []; 
                layoutRowCount = 0;

                for (const block of sortedBlocks) {
                    const blockStart = new Date(block.startISO).getTime();
                    let placed = false;

                    for (let i = 0; i < rows.length; i++) {
                        if (blockStart >= rows[i]) { 
                            rows[i] = new Date(block.endISO).getTime(); 
                            block.layoutRow = i; 
                            placed = true;
                            break;
                        }
                    }

                    if (!placed) {
                        rows.push(new Date(block.endISO).getTime());
                        block.layoutRow = rows.length - 1;
                    }
                }
                layoutRowCount = rows.length;
            }

            function timeToX(ms) {
                return H_PADDING + (ms - minTimeMs) * pxPerMs;
            }
            
            function formatTime(date) {
                return date.toTimeString().substring(0, 5);
            }

            // 汎用描画関数 (画面用 & 画像出力用)
            function drawTimeline(targetCtx, width, height, isExport) {
                const topMargin = isExport ? HEADER_HEIGHT_EXPORT : 0;
                const actualVPadding = V_PADDING + topMargin;

                updateTimelineBounds();
                calculateBlockLayout(); // レイアウト計算 (ドラッグドロップ後はここで自動整列される)

                totalDurationMs = maxTimeMs - minTimeMs;
                
                // スケール計算 (画面幅に合わせるか、最小幅を確保するか)
                const minWidth = isExport ? 1200 : canvasContainer.clientWidth; // 出力時は最低1200px確保
                const calculatedWidth = totalDurationMs * (800 / (4 * 60 * 60 * 1000)); 
                const finalWidth = Math.max(minWidth, calculatedWidth) + H_PADDING * 2;
                
                // 高さ計算
                const contentHeight = (layoutRowCount * ROW_HEIGHT) + V_PADDING * 2 + topMargin;
                const finalHeight = Math.max(400, contentHeight);

                // コンテキスト設定
                targetCtx.canvas.width = finalWidth;
                targetCtx.canvas.height = finalHeight;
                pxPerMs = (finalWidth - H_PADDING * 2) / totalDurationMs;

                // 背景 (白)
                targetCtx.fillStyle = '#ffffff';
                targetCtx.fillRect(0, 0, finalWidth, finalHeight);

                // --- 画像出力用ヘッダー描画 ---
                if (isExport) {
                    // アイコン
                    const iconSize = 50;
                    targetCtx.drawImage(appIcon, 20, 15, iconSize, iconSize);
                    
                    // アプリ名 & プロジェクト名
                    targetCtx.fillStyle = '#333';
                    targetCtx.font = FONT_TITLE;
                    targetCtx.textAlign = 'left';
                    targetCtx.textBaseline = 'middle';
                    targetCtx.fillText(`BloSke - ${currentProjectName}`, 20 + iconSize + 15, 15 + iconSize / 2);
                    targetCtx.textBaseline = 'alphabetic'; // 戻す
                }

                // データなし
                if (projectBlocks.length === 0) {
                    targetCtx.fillStyle = '#adb5bd';
                    targetCtx.font = '16px sans-serif';
                    targetCtx.textAlign = 'center';
                    targetCtx.fillText('イベントが1つも登録されていません。', finalWidth / 2, finalHeight / 2);
                    return;
                }

                // --- 時間軸 ---
                const FOUR_HOURS_MS = 4 * 60 * 60 * 1000;
                const stepMs = (totalDurationMs <= FOUR_HOURS_MS) ? (30 * 60 * 1000) : (60 * 60 * 1000); 
                
                targetCtx.strokeStyle = '#e9ecef'; 
                targetCtx.fillStyle = '#868e96'; 
                targetCtx.font = FONT_S;
                targetCtx.textAlign = 'center';

                for (let t = minTimeMs; t <= maxTimeMs; t += stepMs) {
                    if (t === minTimeMs || t === maxTimeMs) continue;

                    const x = timeToX(t);
                    targetCtx.beginPath();
                    targetCtx.moveTo(x, actualVPadding - 10);
                    targetCtx.lineTo(x, finalHeight - (V_PADDING / 2));
                    targetCtx.stroke();
                    
                    targetCtx.fillText(formatTime(new Date(t)), x, actualVPadding - 15);
                }

                // --- 左右の太線 ---
                targetCtx.strokeStyle = '#333';
                targetCtx.lineWidth = 2;
                targetCtx.fillStyle = '#333';
                targetCtx.font = FONT_L;
                
                const minDate = new Date(minTimeMs);
                const maxDate = new Date(maxTimeMs);
                
                const xStart = timeToX(minTimeMs);
                targetCtx.beginPath();
                targetCtx.moveTo(xStart, actualVPadding - 20);
                targetCtx.lineTo(xStart, finalHeight - (V_PADDING / 2));
                targetCtx.stroke();
                targetCtx.fillText(formatTime(minDate), xStart, actualVPadding - 25);
                
                const xEnd = timeToX(maxTimeMs);
                targetCtx.beginPath();
                targetCtx.moveTo(xEnd, actualVPadding - 20);
                targetCtx.lineTo(xEnd, finalHeight - (V_PADDING / 2));
                targetCtx.stroke();
                targetCtx.fillText(formatTime(maxDate), xEnd, actualVPadding - 25);
                
                if (minDate.toDateString() !== maxDate.toDateString()) {
                    targetCtx.font = FONT_S;
                    targetCtx.fillText(minDate.toLocaleDateString('ja-JP'), xStart, actualVPadding - 40);
                    targetCtx.fillText(maxDate.toLocaleDateString('ja-JP'), xEnd, actualVPadding - 40);
                }

                // --- ブロック描画 ---
                // ドラッグ中のブロックを最後に描画するため、リストを分ける
                const normalBlocks = [];
                const draggingBlockList = [];

                projectBlocks.forEach(block => {
                    if (!isExport && isDragging && dragTargetBlock === block) {
                        draggingBlockList.push(block);
                    } else {
                        normalBlocks.push(block);
                    }
                });

                // 描画関数
                const renderBlock = (block, isDragRender) => {
                    const start = new Date(block.startISO);
                    const end = new Date(block.endISO);
                    
                    const x = timeToX(start.getTime());
                    let y = actualVPadding + (block.layoutRow * ROW_HEIGHT);
                    const width = (end.getTime() - start.getTime()) * pxPerMs;
                    const height = ROW_HEIGHT * 0.8; 

                    // ドラッグ中のY座標上書き
                    if (isDragRender) {
                        y = dragCurrentY; 
                    }

                    targetCtx.fillStyle = block.color;
                    if (isDragRender) targetCtx.globalAlpha = 0.7; // ドラッグ中は半透明
                    
                    roundRect(targetCtx, x, y, width, height, 5, true, false);
                    
                    targetCtx.globalAlpha = 1.0;

                    targetCtx.fillStyle = '#ffffff'; 
                    targetCtx.font = FONT_L;
                    targetCtx.textAlign = 'left';
                    
                    targetCtx.save();
                    targetCtx.beginPath();
                    targetCtx.rect(x, y, width, height);
                    targetCtx.clip();
                    
                    targetCtx.fillText(block.name, x + 8, y + 20);
                    targetCtx.font = FONT_S;
                    targetCtx.fillText(formatTime(start), x + 8, y + 38);
                    targetCtx.textAlign = 'right';
                    targetCtx.fillText(formatTime(end), x + width - 8, y + 38);
                    targetCtx.restore();

                    if (!isExport) {
                        block.hitBox = { x, y, width, height };
                        
                        if (isEditMode) {
                            const delX = x + width - DELETE_BTN_SIZE + 5;
                            const delY = y - 5;
                            targetCtx.fillStyle = 'rgba(220, 53, 69, 1)'; 
                            targetCtx.beginPath();
                            targetCtx.arc(delX, delY, DELETE_BTN_SIZE / 2, 0, Math.PI * 2);
                            targetCtx.fill();
                            
                            targetCtx.fillStyle = '#ffffff';
                            targetCtx.font = 'bold 12px sans-serif';
                            targetCtx.textAlign = 'center';
                            targetCtx.textBaseline = 'middle';
                            targetCtx.fillText('×', delX, delY);
                            targetCtx.textBaseline = 'alphabetic';

                            block.deleteHitBox = { 
                                x: delX - DELETE_BTN_SIZE/2, 
                                y: delY - DELETE_BTN_SIZE/2, 
                                width: DELETE_BTN_SIZE, 
                                height: DELETE_BTN_SIZE 
                            };
                        } else {
                            block.deleteHitBox = null;
                        }
                    }
                };

                // 通常ブロック描画
                normalBlocks.forEach(b => renderBlock(b, false));
                // ドラッグ中ブロック描画（最前面）
                draggingBlockList.forEach(b => renderBlock(b, true));

                // --- 画像出力用フッター (日時) ---
                if (isExport) {
                    const now = new Date();
                    const dateStr = now.toLocaleString('ja-JP');
                    targetCtx.fillStyle = '#888';
                    targetCtx.font = '12px sans-serif';
                    targetCtx.textAlign = 'right';
                    targetCtx.fillText(`出力日時: ${dateStr}`, finalWidth - 20, finalHeight - 10);
                }
            }

            // 画面用ラッパー
            function drawCanvas() {
                drawTimeline(ctx, canvas.width, canvas.height, false);
            }
            
            // 角丸矩形描画ヘルパー
            function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
                if (typeof stroke === 'undefined') { stroke = true; }
                if (typeof radius === 'undefined') { radius = 5; }
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                if (fill) { ctx.fill(); }
                if (stroke) { ctx.stroke(); }
            }

            // --- 3. イベントリスナー (ボタン) ---

            projectNameEl.addEventListener('click', () => {
                const newName = prompt('新しいプロジェクト名を入力してください:', currentProjectName);
                if (newName && newName.trim() !== '') {
                    currentProjectName = newName.trim();
                    projectNameEl.textContent = currentProjectName;
                    saveToLocalStorage(); 
                }
            });

            document.getElementById('add-block-btn').addEventListener('click', () => {
                editingBlockId = null; 
                document.getElementById('block-modal-title').textContent = 'ブロック追加';
                document.getElementById('block-edit-form').reset();
                document.getElementById('block-id').value = '';
                
                const now = new Date();
                const yyyyMMdd = now.toISOString().split('T')[0];
                const hhMM = now.toTimeString().substring(0, 5);
                document.getElementById('block-start-date').value = yyyyMMdd;
                document.getElementById('block-start-time').value = hhMM;
                document.getElementById('block-end-date').value = yyyyMMdd;
                document.getElementById('block-end-time').value = hhMM;

                blockColorInput.value = colors[0];
                 Array.from(colorPicker.children).forEach((child, index) => {
                    child.style.borderColor = (index === 0) ? '#333' : 'transparent';
                });
                showModal('block-edit-modal');
            });
            
            document.getElementById('edit-mode-btn').addEventListener('click', (e) => {
                isEditMode = !isEditMode;
                const btn = e.currentTarget;
                if (isEditMode) {
                    btn.innerHTML = '<i class="fa-solid fa-check"></i> 編集モード終了';
                    btn.classList.add('btn-primary');
                    btn.classList.remove('btn-secondary');
                    canvas.classList.add('edit-mode-active');
                } else {
                    btn.innerHTML = '<i class="fa-solid fa-pen"></i> 編集モード';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                    canvas.classList.remove('edit-mode-active');
                }
                drawCanvas(); 
            });

            document.getElementById('reset-btn').addEventListener('click', () => {
                if (confirm('プロジェクトをリセットしますか？\n（すべてのブロックが削除されます）')) {
                    projectBlocks = [];
                    saveToLocalStorage();
                    drawCanvas();
                }
            });

            document.getElementById('save-btn').addEventListener('click', () => {
                const user = getUserSession();
                if (!user) {
                    alert('プロジェクトを保存するにはログインが必要です。');
                    sessionStorage.setItem('login_redirect_reason', 'save');
                    window.location.href = 'login.html';
                    return;
                }
                saveProjectData(user.username);
            });

            // --- 画像出力 ---
            document.getElementById('export-img-btn').addEventListener('click', () => {
                if (projectBlocks.length === 0) {
                    alert('出力するブロックがありません。');
                    return;
                }
                
                try {
                    // 出力用の一時Canvasを作成
                    const exportCanvas = document.createElement('canvas');
                    const exportCtx = exportCanvas.getContext('2d');
                    
                    // 画像用描画 (isExport = true)
                    drawTimeline(exportCtx, 0, 0, true);
                    
                    const dataUrl = exportCanvas.toDataURL('image/png');
                    
                    // ファイル名生成 (プロジェクト名_YYYYMMDD_HHmm)
                    const now = new Date();
                    const yyyy = now.getFullYear();
                    const MM = String(now.getMonth() + 1).padStart(2, '0');
                    const dd = String(now.getDate()).padStart(2, '0');
                    const HH = String(now.getHours()).padStart(2, '0');
                    const mm = String(now.getMinutes()).padStart(2, '0');
                    const fileName = `${currentProjectName}_${yyyy}${MM}${dd}_${HH}${mm}.png`;

                    const link = document.createElement('a');
                    link.download = fileName;
                    link.href = dataUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } catch (e) {
                    console.error('画像出力エラー:', e);
                    alert('画像の出力に失敗しました。');
                }
            });

            // --- 4. イベントリスナー (モーダル) ---

            setupModalClose('block-edit-modal', '#cancel-block-edit-btn');
            const blockEditForm = document.getElementById('block-edit-form');
            const colors = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', '#64748B'];
            const colorPicker = document.getElementById('color-picker');
            const blockColorInput = document.getElementById('block-color');

            colors.forEach(color => {
                const colorCircle = document.createElement('div');
                colorCircle.style.width = '30px';
                colorCircle.style.height = '30px';
                colorCircle.style.borderRadius = '50%';
                colorCircle.style.backgroundColor = color;
                colorCircle.style.cursor = 'pointer';
                colorCircle.style.border = '3px solid transparent';
                colorCircle.dataset.color = color;
                
                if (color === blockColorInput.value) {
                    colorCircle.style.borderColor = '#333';
                }

                colorCircle.addEventListener('click', () => {
                    blockColorInput.value = color;
                    Array.from(colorPicker.children).forEach(child => {
                        child.style.borderColor = 'transparent';
                    });
                    colorCircle.style.borderColor = '#333';
                });
                colorPicker.appendChild(colorCircle);
            });

            blockEditForm.addEventListener('submit', (e) => {
                e.preventDefault();
                
                const name = document.getElementById('block-name').value;
                const startDate = document.getElementById('block-start-date').value;
                const startTime = document.getElementById('block-start-time').value;
                const endDate = document.getElementById('block-end-date').value;
                const endTime = document.getElementById('block-end-time').value;
                const color = document.getElementById('block-color').value;

                if (!name || !startDate || !startTime || !endDate || !endTime) {
                    alert('すべての日時を入力してください。');
                    return;
                }
                
                const startISO = new Date(`${startDate}T${startTime}`).toISOString();
                const endISO = new Date(`${endDate}T${endTime}`).toISOString();

                if (new Date(endISO) <= new Date(startISO)) {
                    alert('終了日時は開始日時より後に設定してください。');
                    return;
                }

                const blockData = { name, startISO, endISO, color };

                if (editingBlockId) {
                    const index = projectBlocks.findIndex(b => b.id === editingBlockId);
                    if (index !== -1) {
                        projectBlocks[index] = { ...projectBlocks[index], ...blockData };
                    }
                } else {
                    projectBlocks.push({
                        ...blockData,
                        id: Date.now().toString()
                    });
                }
                
                editingBlockId = null; 
                saveToLocalStorage();
                drawCanvas();
                hideModal('block-edit-modal');
            });

            // --- 5. イベントリスナー (Canvas操作: 編集/削除/ドラッグ) ---

            function openEditModal(block) {
                editingBlockId = block.id; 
                document.getElementById('block-modal-title').textContent = 'ブロック編集';
                
                document.getElementById('block-id').value = block.id;
                document.getElementById('block-name').value = block.name;
                
                const start = new Date(block.startISO);
                const end = new Date(block.endISO);
                
                document.getElementById('block-start-date').value = start.toISOString().split('T')[0];
                document.getElementById('block-start-time').value = start.toTimeString().substring(0, 5);
                document.getElementById('block-end-date').value = end.toISOString().split('T')[0];
                document.getElementById('block-end-time').value = end.toTimeString().substring(0, 5);

                blockColorInput.value = block.color;
                Array.from(colorPicker.children).forEach(child => {
                    child.style.borderColor = (child.dataset.color === block.color) ? '#333' : 'transparent';
                });

                showModal('block-edit-modal');
            }

            function getCanvasCoordinates(e) {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                return {
                    x: clientX - rect.left + canvasContainer.scrollLeft,
                    y: clientY - rect.top + canvasContainer.scrollTop
                };
            }

            // --- マウスダウン / タッチスタート ---
            function handleInputStart(e) {
                if (isEditMode) {
                    handleClickInEditMode(e);
                    return;
                }

                const pos = getCanvasCoordinates(e);
                
                for (const block of [...projectBlocks].reverse()) {
                    if (!block.hitBox) continue;
                    const h = block.hitBox;
                    if (pos.x >= h.x && pos.x <= h.x + h.width && pos.y >= h.y && pos.y <= h.y + h.height) {
                        isDragging = true;
                        dragTargetBlock = block;
                        dragStartX = pos.x;
                        // Y軸追従用: オフセットを計算
                        dragOffsetY = pos.y - h.y;
                        dragCurrentY = h.y; // 初期位置
                        dragOriginalStartMs = new Date(block.startISO).getTime();
                        dragOriginalEndMs = new Date(block.endISO).getTime();
                        
                        canvas.classList.add('dragging');
                        if (e.type === 'touchstart') e.preventDefault(); 
                        break;
                    }
                }
            }

            // --- 編集モードでのクリック判定 ---
            function handleClickInEditMode(e) {
                const pos = getCanvasCoordinates(e);
                
                for (const block of [...projectBlocks].reverse()) {
                    if (!block.hitBox) continue;
                    
                    const d = block.deleteHitBox;
                    if (d && pos.x >= d.x && pos.x <= d.x + d.width && pos.y >= d.y && pos.y <= d.y + d.height) {
                        if (confirm(`「${block.name}」を本当に削除しますか？`)) {
                            projectBlocks = projectBlocks.filter(b => b.id !== block.id);
                            saveToLocalStorage();
                            drawCanvas();
                        }
                        return;
                    }
                    
                    const h = block.hitBox;
                    if (pos.x >= h.x && pos.x <= h.x + h.width && pos.y >= h.y && pos.y <= h.y + h.height) {
                        openEditModal(block);
                        return;
                    }
                }
            }

            // --- マウスムーブ / タッチムーブ ---
            function handleInputMove(e) {
                if (!isDragging || !dragTargetBlock) return;
                
                e.preventDefault(); 
                const pos = getCanvasCoordinates(e);
                const deltaX = pos.x - dragStartX;
                
                // X軸 (時間) 更新
                const deltaMs = deltaX / pxPerMs;
                const newStartMs = dragOriginalStartMs + deltaMs;
                const newEndMs = dragOriginalEndMs + deltaMs;
                dragTargetBlock.startISO = new Date(newStartMs).toISOString();
                dragTargetBlock.endISO = new Date(newEndMs).toISOString();

                // Y軸 (表示位置) 更新
                dragCurrentY = pos.y - dragOffsetY;
                
                drawCanvas(); 
            }

            // --- マウスアップ / タッチエンド ---
            function handleInputEnd(e) {
                if (isDragging) {
                    isDragging = false;
                    dragTargetBlock = null;
                    canvas.classList.remove('dragging');
                    
                    // 変更を保存し、再描画 (これで自動レイアウトによりY位置が確定し、ハイライトも消える)
                    saveToLocalStorage(); 
                    drawCanvas();
                }
            }

            canvas.addEventListener('mousedown', handleInputStart);
            canvas.addEventListener('mousemove', handleInputMove);
            canvas.addEventListener('mouseup', handleInputEnd);
            canvas.addEventListener('mouseleave', handleInputEnd);

            canvas.addEventListener('touchstart', handleInputStart, {passive: false});
            canvas.addEventListener('touchmove', handleInputMove, {passive: false});
            canvas.addEventListener('touchend', handleInputEnd);


            // --- 6. 最終初期化処理 ---

            const urlParams = new URLSearchParams(window.location.search);
            const loadedCsvData = sessionStorage.getItem('bloske_loaded_csv');
            
            if (loadedCsvData) {
                currentProjectName = sessionStorage.getItem('bloske_current_project_name') || '読み込みプロジェクト';
                projectBlocks = parseCsvData(loadedCsvData);
                sessionStorage.removeItem('bloske_loaded_csv'); 
                sessionStorage.removeItem('bloske_current_project_name');
            } else if (urlParams.has('restore')) {
                loadFromLocalStorage();
            } else {
                currentProjectName = sessionStorage.getItem('bloske_current_project_name') || '新規プロジェクト';
                sessionStorage.removeItem('bloske_current_project_name');
            }
            projectNameEl.textContent = currentProjectName;
            
            drawCanvas(); 
            window.addEventListener('resize', drawCanvas);

            async function saveProjectData(username) {
                const projectName = projectNameEl.textContent;
                
                let csvData = "ブロック名,開始日時ISO,終了日時ISO,カラーコード\n"; 
                projectBlocks.forEach(block => {
                    const name = `"${block.name.replace(/"/g, '""')}"`;
                    csvData += `${name},"${block.startISO}","${block.endISO}","${block.color}"\n`;
                });
                
                if (!confirm(`プロジェクト「${projectName}」を保存しますか？`)) {
                    return;
                }

                try {
                    await callGasApi('saveProject', {
                        username: username,
                        projectName: projectName,
                        csvData: csvData
                    });
                    alert('保存しました。');
                    localStorage.removeItem('bloske_local_project');
                } catch (error) {
                    console.error('保存失敗:', error);
                }
            }
        });
    </script>
</body>
</html>
