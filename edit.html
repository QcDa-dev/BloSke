<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>編集画面 - BloSke</title>
    
    <!-- アイコン設定 -->
    <link rel="icon" href="favicon.ico" sizes="any">
    <link rel="icon" href="icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">

    <!-- 共通スタイル -->
    <link rel="stylesheet" href="common.css">

    <!-- Firebase SDK (common.js より先に読み込む) -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>

    <!-- このページ専用のスタイル -->
    <style>
        /* (common.css で定義済み) */
        
        /* Canvasのカーソル制御 */
        #timetableCanvas {
            cursor: default;
        }
        #timetableCanvas.edit-mode-active {
            cursor: pointer; /* 編集モード時はポインター */
        }
        #timetableCanvas.dragging {
            cursor: grab; /* ドラッグ可能 */
        }
        #timetableCanvas.dragging:active {
            cursor: grabbing; /* 掴んでいる最中 */
        }
    </style>
</head>
<body>

    <main>
        <div id="edit-container">
            <!-- プロジェクト名 -->
            <h2 id="project-title" class="project-title" title="クリックして編集">my project</h2>

            <!-- ボタンフィールド -->
            <div class="button-field">
                <button id="add-block-btn" class="btn btn-primary"><i class="fa-solid fa-plus"></i> ブロック追加</button>
                <button id="edit-mode-btn" class="btn btn-secondary"><i class="fa-solid fa-pen"></i> 編集モード</button>
                <button id="toggle-view-btn" class="btn btn-secondary"><i class="fa-solid fa-arrows-left-right"></i> 縦横切替</button>
                <button id="save-btn" class="btn btn-secondary"><i class="fa-solid fa-save"></i> 保存</button>
                <button id="export-img-btn" class="btn btn-secondary"><i class="fa-solid fa-image"></i> 画像出力</button>
                <button id="reset-btn" class="btn btn-secondary" style="color: #dc3545;"><i class="fa-solid fa-trash"></i> リセット</button>
            </div>

            <!-- タイムテーブルフィールド (Canvas) -->
            <div id="timetable-canvas-container">
                <canvas id="timetableCanvas" width="1000" height="400">
                    お使いのブラウザはCanvasに対応していません。
                </canvas>
            </div>
            
            <!-- オプション -->
            <div class="canvas-options">
                <input type="checkbox" id="two-column-toggle">
                <label for="two-column-toggle">2段組表示</label>
            </div>
        </div>
    </main>

    <!-- ブロック情報編集ウィンドウ (モーダル) -->
    <div id="block-edit-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="block-modal-title" class="modal-title">ブロック情報</h2>
            <form id="block-edit-form">
                <input type="hidden" id="block-id"> 
                
                <div class="form-group">
                    <label for="block-name">ブロック名</label>
                    <input type="text" id="block-name" class="form-input" required>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <div class="form-group" style="flex: 2;">
                        <label for="block-start-date">開始日</label>
                        <input type="date" id="block-start-date" class="form-input" required>
                    </div>
                    <div class="form-group" style="flex: 1;">
                        <label for="block-start-time">開始時刻</label>
                        <input type="time" id="block-start-time" class="form-input" required>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <div class="form-group" style="flex: 2;">
                        <label for="block-end-date">終了日</label>
                        <input type="date" id="block-end-date" class="form-input" required>
                    </div>
                    <div class="form-group" style="flex: 1;">
                        <label for="block-end-time">終了時刻</label>
                        <input type="time" id="block-end-time" class="form-input" required>
                    </div>
                </div>

                <div class="form-group">
                    <label>カラー</label>
                    <div id="color-picker" style="display: flex; justify-content: space-around; padding: 10px 0;">
                        <!-- JSで動的に生成 -->
                    </div>
                    <input type="hidden" id="block-color" value="#3B82F6">
                </div>

                <div class="modal-actions">
                    <button type="button" id="cancel-block-edit-btn" class="btn btn-secondary">キャンセル</button>
                    <button type="submit" class="btn btn-primary">決定</button>
                </div>
            </form>
        </div>
    </div>

    <!-- 共通スクリプト -->
    <script src="common.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            initCommonUI('BloSke');

            // --- グローバル変数・定数 ---
            const projectNameEl = document.getElementById('project-title');
            const canvasContainer = document.getElementById('timetable-canvas-container');
            const canvas = document.getElementById('timetableCanvas');
            const ctx = canvas.getContext('2d');
            
            const PADDING_MAIN = 60;  
            const PADDING_CROSS = 40; 
            const ROW_SIZE = 60;      
            const GAP_2COL = 60;      
            const DELETE_BTN_SIZE = 20;
            const HEADER_HEIGHT_EXPORT = 80; 
            
            const FONT_S = '12px sans-serif';
            const FONT_M = '14px sans-serif';
            const FONT_L = 'bold 14px sans-serif';
            const FONT_TITLE = 'bold 24px sans-serif';
            
            let projectBlocks = []; // {..., hitBoxes: []}
            let currentProjectName = '新規プロジェクト';
            let isEditMode = false;
            let editingBlockId = null;
            
            let isVertical = false;   
            let isTwoColumn = false;  

            let minTimeMs = 0; 
            let maxTimeMs = 0; 
            let totalDurationMs = 0; 
            let pxPerMs = 0; 
            let layoutRowCount = 0; 
            
            // 描画オフセット（中央揃え用）
            let contentOffsetX = 0;
            let contentOffsetY = 0;

            let isDragging = false;
            let dragTargetBlock = null;
            let dragStartX = 0;
            let dragOriginalStartMs = 0;
            let dragOriginalEndMs = 0;
            let dragOriginalRow = 0; 
            let dragOffset = 0; 
            let dragCrossOffset = 0; 
            let dragCurrentPos = { x: 0, y: 0 };

            const appIcon = new Image();
            appIcon.src = 'icon.svg';

            // --- 1. データ読み込み・初期化 ---

            function parseCsvData(csvData) {
                const lines = csvData.trim().split('\n');
                const blocks = [];
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i];
                    const parts = line.split(',').map(part => part.trim().replace(/"/g, ''));
                    if (parts.length >= 4) {
                        blocks.push({
                            id: Date.now().toString() + i,
                            name: parts[0],
                            startISO: parts[1],
                            endISO: parts[2],
                            color: parts[3],
                            layoutRow: -1
                        });
                    }
                }
                return blocks;
            }

            function loadFromLocalStorage() {
                try {
                    const dataStr = localStorage.getItem('bloske_local_project');
                    if (!dataStr) return;
                    const data = JSON.parse(dataStr);
                    currentProjectName = data.name || '復元プロジェクト';
                    projectBlocks = data.blocks || [];
                } catch (e) {
                    console.error('ローカルストレージ復元失敗:', e);
                    localStorage.removeItem('bloske_local_project');
                }
            }
            
            function saveToLocalStorage() {
                const data = { name: currentProjectName, blocks: projectBlocks };
                localStorage.setItem('bloske_local_project', JSON.stringify(data));
            }

            // --- 2. レイアウトロジック ---

            function findAvailableRow(targetBlock) {
                const targetStart = new Date(targetBlock.startISO).getTime();
                const targetEnd = new Date(targetBlock.endISO).getTime();
                let row = 0;
                while (true) {
                    const conflict = projectBlocks.some(other => {
                        if (other === targetBlock || other.layoutRow !== row) return false;
                        const otherStart = new Date(other.startISO).getTime();
                        const otherEnd = new Date(other.endISO).getTime();
                        return targetStart < otherEnd && targetEnd > otherStart;
                    });
                    if (!conflict) return row;
                    row++;
                }
            }

            function assignLayoutRows() {
                projectBlocks.forEach(block => {
                    if (typeof block.layoutRow === 'undefined' || block.layoutRow === -1) {
                        block.layoutRow = findAvailableRow(block);
                    }
                });
            }

            function calculateRowCount() {
                let maxRow = -1;
                projectBlocks.forEach(block => {
                    if (block.layoutRow > maxRow) maxRow = block.layoutRow;
                });
                layoutRowCount = Math.max(1, maxRow + 2); 
            }

            // --- 3. Canvas描画ロジック ---

            function updateTimelineBounds() {
                if (projectBlocks.length === 0) {
                    const now = new Date();
                    minTimeMs = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours()).getTime(); 
                    maxTimeMs = minTimeMs + (4 * 60 * 60 * 1000); 
                    return;
                }
                let minStart = Infinity;
                let maxEnd = -Infinity;
                projectBlocks.forEach(block => {
                    const start = new Date(block.startISO).getTime();
                    const end = new Date(block.endISO).getTime();
                    if (start < minStart) minStart = start;
                    if (end > maxEnd) maxEnd = end;
                });
                
                // 丸め処理
                const roundMs = (ms, up) => {
                    const d = new Date(ms);
                    const m = d.getMinutes();
                    if (up) {
                        if (m > 30) d.setHours(d.getHours() + 1, 0, 0, 0);
                        else if (m > 0) d.setMinutes(30, 0, 0);
                    } else {
                        if (m >= 30) d.setMinutes(30, 0, 0);
                        else d.setMinutes(0, 0, 0);
                    }
                    return d.getTime();
                };
                minTimeMs = roundMs(minStart, false);
                maxTimeMs = roundMs(maxEnd, true);
                if (maxTimeMs - minTimeMs < 3600000) maxTimeMs = minTimeMs + 3600000;
            }

            function formatTime(date) {
                return date.toTimeString().substring(0, 5);
            }

            // 座標計算ヘルパー (中央揃えオフセット加算済み)
            function getRect(timeStart, timeEnd, row, section, isExport) {
                const topMargin = isExport ? HEADER_HEIGHT_EXPORT : 0;
                
                // 期間全体の中間 (セクションの境界)
                const midTimeMs = minTimeMs + (totalDurationMs / 2);
                const sectionStartMs = (section === 0) ? minTimeMs : midTimeMs;
                
                const relStart = timeStart - sectionStartMs;
                const relEnd = timeEnd - sectionStartMs;
                
                const length = (relEnd - relStart) * pxPerMs;
                const startPos = PADDING_MAIN + (relStart * pxPerMs);
                
                let baseCross = 0;
                if (isTwoColumn && section === 1) {
                    baseCross = (layoutRowCount * ROW_SIZE) + GAP_2COL;
                }

                const rowPos = PADDING_CROSS + topMargin + baseCross + (row * ROW_SIZE);

                if (!isVertical) {
                    // 横表示
                    return {
                        x: startPos + contentOffsetX, // 中央揃え
                        y: rowPos + contentOffsetY,   // 中央揃え
                        w: length,
                        h: ROW_SIZE * 0.8
                    };
                } else {
                    // 縦表示
                    return {
                        x: rowPos + contentOffsetX,   // 中央揃え
                        y: startPos + contentOffsetY, // 中央揃え
                        w: ROW_SIZE * 0.8,
                        h: length
                    };
                }
            }

            function drawTimeline(targetCtx, isExport) {
                const topMargin = isExport ? HEADER_HEIGHT_EXPORT : 0;
                
                assignLayoutRows();
                updateTimelineBounds();
                calculateRowCount();

                totalDurationMs = maxTimeMs - minTimeMs;
                const displayDurationMs = isTwoColumn ? (totalDurationMs / 2) : totalDurationMs;

                // コンテンツの本来のサイズ (パディング込み)
                const contentMainLength = (displayDurationMs * (800 / (4 * 3600000))) + PADDING_MAIN * 2;
                let contentCrossLength = (layoutRowCount * ROW_SIZE) + PADDING_CROSS * 2 + topMargin;
                if (isTwoColumn) {
                    contentCrossLength = (contentCrossLength - PADDING_CROSS * 2 - topMargin) * 2 + GAP_2COL + PADDING_CROSS * 2 + topMargin;
                }
                
                // 最低サイズ
                const minWidth = isExport ? 1200 : canvasContainer.clientWidth;
                const minHeight = isExport ? (contentCrossLength + 100) : 400;

                // Canvasサイズ (コンテンツサイズと最低サイズの大きい方)
                // 横表示なら contentMainLength が幅、contentCrossLength が高さ
                let canvasW, canvasH;
                if (!isVertical) {
                    canvasW = Math.max(minWidth, contentMainLength);
                    canvasH = Math.max(minHeight, contentCrossLength);
                } else {
                    canvasW = Math.max(minWidth, contentCrossLength);
                    canvasH = Math.max(minHeight, contentMainLength);
                }

                targetCtx.canvas.width = canvasW;
                targetCtx.canvas.height = canvasH;

                // pxPerMs の再計算 (描画領域の長さに合わせる)
                // コンテンツの実サイズを基準にするため、計算式は固定値ベースで維持
                // 伸縮させたい場合はここを変えるが、今回はサイズ固定で中央寄せする
                pxPerMs = (contentMainLength - PADDING_MAIN * 2) / displayDurationMs;

                // 中央揃えオフセット計算
                // Canvas全体の中で、コンテンツ(contentMainLength/contentCrossLength)を中央に配置
                if (!isVertical) {
                    contentOffsetX = Math.max(0, (canvasW - contentMainLength) / 2);
                    contentOffsetY = Math.max(0, (canvasH - contentCrossLength) / 2);
                } else {
                    contentOffsetX = Math.max(0, (canvasW - contentCrossLength) / 2);
                    contentOffsetY = Math.max(0, (canvasH - contentMainLength) / 2);
                }

                // 背景
                targetCtx.fillStyle = '#ffffff';
                targetCtx.fillRect(0, 0, canvasW, canvasH);

                // ヘッダー (画像出力)
                if (isExport) {
                    const iconSize = 50;
                    targetCtx.drawImage(appIcon, 20, 15, iconSize, iconSize);
                    targetCtx.fillStyle = '#333';
                    targetCtx.font = FONT_TITLE;
                    targetCtx.textAlign = 'left';
                    targetCtx.textBaseline = 'middle';
                    targetCtx.fillText(`BloSke - ${currentProjectName}`, 20 + iconSize + 15, 15 + iconSize / 2);
                    targetCtx.textBaseline = 'alphabetic'; 
                }

                // データなし
                if (projectBlocks.length === 0) {
                    targetCtx.fillStyle = '#adb5bd';
                    targetCtx.font = '16px sans-serif';
                    targetCtx.textAlign = 'center';
                    targetCtx.fillText('イベントが1つも登録されていません。', canvasW / 2, canvasH / 2);
                    return;
                }

                // ヒットボックス初期化 (画面描画時のみ)
                if (!isExport) {
                    projectBlocks.forEach(b => b.hitBoxes = []);
                }

                // --- 描画ループ (セクションごと) ---
                const sections = isTwoColumn ? 2 : 1;
                const midTimeMs = minTimeMs + (totalDurationMs / 2);

                for (let section = 0; section < sections; section++) {
                    const secStart = (section === 0) ? minTimeMs : midTimeMs;
                    const secEnd = (section === 0) ? (isTwoColumn ? midTimeMs : maxTimeMs) : maxTimeMs;

                    // 1. 時間軸とグリッド
                    const FOUR_HOURS = 4 * 3600000;
                    const stepMs = (totalDurationMs <= FOUR_HOURS) ? 1800000 : 3600000; // 30m or 1h
                    
                    targetCtx.strokeStyle = '#e9ecef'; 
                    targetCtx.fillStyle = '#868e96'; 
                    targetCtx.font = FONT_S;
                    targetCtx.textAlign = 'center';
                    targetCtx.textBaseline = 'middle';

                    // グリッド線描画範囲 (行の端から端まで)
                    const layoutStartRow = 0;
                    const layoutEndRow = layoutRowCount;

                    for (let t = secStart; t <= secEnd; t += stepMs) {
                        if (t === secStart || t === secEnd) continue;

                        const rectStart = getRect(t, t, layoutStartRow, section, isExport);
                        const rectEnd = getRect(t, t, layoutEndRow, section, isExport);
                        
                        targetCtx.beginPath();
                        if (!isVertical) {
                            // 横表示: 縦線
                            targetCtx.moveTo(rectStart.x, rectStart.y - 10); // 上へ少しはみ出す
                            targetCtx.lineTo(rectEnd.x, rectEnd.y);
                            targetCtx.fillText(formatTime(new Date(t)), rectStart.x, rectStart.y - 15);
                        } else {
                            // 縦表示: 横線
                            targetCtx.moveTo(rectStart.x - 10, rectStart.y);
                            targetCtx.lineTo(rectEnd.x, rectEnd.y);
                            targetCtx.textAlign = 'right';
                            targetCtx.fillText(formatTime(new Date(t)), rectStart.x - 15, rectStart.y);
                            targetCtx.textAlign = 'center';
                        }
                        targetCtx.stroke();
                    }

                    // 2. 太線 (両端)
                    targetCtx.strokeStyle = '#333';
                    targetCtx.lineWidth = 2;
                    targetCtx.fillStyle = '#333';
                    targetCtx.font = FONT_L;

                    [secStart, secEnd].forEach(t => {
                        const rectStart = getRect(t, t, layoutStartRow, section, isExport);
                        const rectEnd = getRect(t, t, layoutEndRow, section, isExport);
                        
                        targetCtx.beginPath();
                        if (!isVertical) {
                            targetCtx.moveTo(rectStart.x, rectStart.y - 20);
                            targetCtx.lineTo(rectEnd.x, rectEnd.y);
                            targetCtx.fillText(formatTime(new Date(t)), rectStart.x, rectStart.y - 25);
                        } else {
                            targetCtx.moveTo(rectStart.x - 20, rectStart.y);
                            targetCtx.lineTo(rectEnd.x, rectEnd.y);
                            targetCtx.textAlign = 'right';
                            targetCtx.fillText(formatTime(new Date(t)), rectStart.x - 25, rectStart.y);
                            targetCtx.textAlign = 'center';
                        }
                        targetCtx.stroke();
                    });
                    targetCtx.lineWidth = 1;

                    // 3. ブロック描画 (このセクションに含まれる部分のみ)
                    const renderBlockInSection = (block, isDragRender) => {
                        const bStart = new Date(block.startISO).getTime();
                        const bEnd = new Date(block.endISO).getTime();

                        // セクションと重なるか判定
                        if (bEnd <= secStart || bStart >= secEnd) return;

                        // 描画範囲をクリップ
                        const drawStart = Math.max(bStart, secStart);
                        const drawEnd = Math.min(bEnd, secEnd);

                        let rect = getRect(drawStart, drawEnd, block.layoutRow, section, isExport);

                        // ドラッグ中の座標上書き (ただし分割表示時はX/Yのどちらかが固定されるべき)
                        // 今回は簡易的に、ドラッグ中は分割表示せず、マウス位置に追従する単一ブロックとして
                        // 「最前面」に描画する方針をとるため、ここ（セクションループ内）では
                        // ドラッグ中のブロックは描画しないのが自然だが、
                        // ユーザー体験として「分割されたままドラッグ」もありうる。
                        // ここでは「ドラッグ中はマウス位置にある」として描画する。
                        // ただし、2段組時のドラッグ描画は複雑になるため、
                        // 「ドラッグターゲット」はセクションループの外で最後にまとめて描画する。
                        if (isDragRender) {
                            return; // ここでは描画しない
                        }

                        targetCtx.fillStyle = block.color;
                        targetCtx.globalAlpha = 1.0;
                        roundRect(targetCtx, rect.x, rect.y, rect.w, rect.h, 5, true, false);

                        targetCtx.fillStyle = '#ffffff';
                        targetCtx.font = FONT_L;
                        targetCtx.save();
                        targetCtx.beginPath();
                        targetCtx.rect(rect.x, rect.y, rect.w, rect.h);
                        targetCtx.clip();

                        if (!isVertical) {
                            targetCtx.textAlign = 'left';
                            targetCtx.fillText(block.name, rect.x + 8, rect.y + 20);
                            targetCtx.font = FONT_S;
                            // 開始時刻は、ブロック本来の開始時刻がこのセクションに含まれる場合のみ表示
                            if (bStart >= secStart) targetCtx.fillText(formatTime(new Date(bStart)), rect.x + 8, rect.y + 38);
                            // 終了時刻
                            if (bEnd <= secEnd) {
                                targetCtx.textAlign = 'right';
                                targetCtx.fillText(formatTime(new Date(bEnd)), rect.x + rect.w - 8, rect.y + 38);
                            }
                        } else {
                            targetCtx.textAlign = 'center';
                            targetCtx.textBaseline = 'top';
                            targetCtx.fillText(block.name, rect.x + rect.w/2, rect.y + 5);
                            targetCtx.font = FONT_S;
                            if (bStart >= secStart) targetCtx.fillText(formatTime(new Date(bStart)), rect.x + rect.w/2, rect.y + 25);
                            if (bEnd <= secEnd) {
                                targetCtx.textBaseline = 'bottom';
                                targetCtx.fillText(formatTime(new Date(bEnd)), rect.x + rect.w/2, rect.y + rect.h - 5);
                            }
                            targetCtx.textBaseline = 'alphabetic';
                        }
                        targetCtx.restore();

                        // ヒットボックス登録 (分割された各パーツを登録)
                        if (!isExport) {
                            block.hitBoxes.push({
                                x: rect.x, y: rect.y, width: rect.w, height: rect.h,
                                section: section
                            });

                            // 編集モードUI
                            if (isEditMode) {
                                const delX = rect.x + rect.w - DELETE_BTN_SIZE + 5;
                                const delY = rect.y - 5;
                                targetCtx.fillStyle = 'rgba(220, 53, 69, 1)';
                                targetCtx.beginPath();
                                targetCtx.arc(delX, delY, DELETE_BTN_SIZE / 2, 0, Math.PI * 2);
                                targetCtx.fill();
                                targetCtx.fillStyle = '#ffffff';
                                targetCtx.font = 'bold 12px sans-serif';
                                targetCtx.textAlign = 'center';
                                targetCtx.textBaseline = 'middle';
                                targetCtx.fillText('×', delX, delY);
                                targetCtx.textBaseline = 'alphabetic';
                                
                                // 削除ボタンのヒットボックスは配列ではなく単一プロパティで管理していたが、
                                // 分割時は複数出るため、配列に追加するか、最後の1つだけ有効にする。
                                // ここでは便宜上、block.deleteHitBoxes 配列を追加して管理する。
                                if (!block.deleteHitBoxes) block.deleteHitBoxes = [];
                                block.deleteHitBoxes.push({ 
                                    x: delX - DELETE_BTN_SIZE/2, 
                                    y: delY - DELETE_BTN_SIZE/2, 
                                    width: DELETE_BTN_SIZE, 
                                    height: DELETE_BTN_SIZE 
                                });
                            } else {
                                block.deleteHitBoxes = [];
                            }
                        }
                    };

                    // 通常ブロック描画
                    projectBlocks.forEach(b => {
                        if (b !== dragTargetBlock) renderBlockInSection(b, false);
                    });
                } // end section loop

                // 4. ドラッグ中ブロックの描画 (最前面・半透明・マウス追従)
                if (isDragging && dragTargetBlock) {
                    // ドラッグ中は分割せず、マウス位置に単一の矩形として表示する方が自然だが、
                    // 2段組のどちらにいるか分かりにくくなるため、
                    // 「現在マウスがあるセクション」に基づいて表示する。
                    // 簡易的に、dragCurrentPos を基点とした矩形を描画。
                    
                    const bStart = new Date(dragTargetBlock.startISO).getTime();
                    const bEnd = new Date(dragTargetBlock.endISO).getTime();
                    const duration = bEnd - bStart;
                    const length = duration * pxPerMs;
                    
                    let rect = { 
                        x: dragCurrentPos.x, 
                        y: dragCurrentPos.y, 
                        w: (!isVertical) ? length : ROW_SIZE * 0.8, 
                        h: (!isVertical) ? ROW_SIZE * 0.8 : length 
                    };

                    targetCtx.globalAlpha = 0.7;
                    targetCtx.fillStyle = dragTargetBlock.color;
                    roundRect(targetCtx, rect.x, rect.y, rect.w, rect.h, 5, true, false);
                    targetCtx.globalAlpha = 1.0;
                    
                    // テキスト (簡易)
                    targetCtx.fillStyle = '#ffffff';
                    targetCtx.font = FONT_L;
                    targetCtx.save();
                    targetCtx.beginPath();
                    targetCtx.rect(rect.x, rect.y, rect.w, rect.h);
                    targetCtx.clip();
                    if (!isVertical) {
                        targetCtx.textAlign = 'left';
                        targetCtx.fillText(dragTargetBlock.name, rect.x + 8, rect.y + 20);
                    } else {
                        targetCtx.textAlign = 'center';
                        targetCtx.textBaseline = 'top';
                        targetCtx.fillText(dragTargetBlock.name, rect.x + rect.w/2, rect.y + 5);
                        targetCtx.textBaseline = 'alphabetic';
                    }
                    targetCtx.restore();
                }

                // 5. 画像出力フッター
                if (isExport) {
                    const now = new Date();
                    const dateStr = now.toLocaleString('ja-JP');
                    targetCtx.fillStyle = '#888';
                    targetCtx.font = '12px sans-serif';
                    targetCtx.textAlign = 'right';
                    targetCtx.fillText(`出力日時: ${dateStr}`, canvasW - 20, canvasH - 10);
                }
            }

            function drawCanvas() {
                drawTimeline(ctx, false);
            }
            
            function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
                if (typeof stroke === 'undefined') { stroke = true; }
                if (typeof radius === 'undefined') { radius = 5; }
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                if (fill) { ctx.fill(); }
                if (stroke) { ctx.stroke(); }
            }

            // --- イベント処理 (一部変更) ---

            function getCanvasCoordinates(e) {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                return {
                    x: clientX - rect.left + canvasContainer.scrollLeft,
                    y: clientY - rect.top + canvasContainer.scrollTop
                };
            }

            function handleInputStart(e) {
                if (isEditMode) {
                    handleClickInEditMode(e);
                    return;
                }
                const pos = getCanvasCoordinates(e);
                
                for (const block of [...projectBlocks].reverse()) {
                    // 分割されたhitBoxesのいずれかにヒットすればOK
                    if (!block.hitBoxes) continue;
                    for (const h of block.hitBoxes) {
                        if (pos.x >= h.x && pos.x <= h.x + h.width && pos.y >= h.y && pos.y <= h.y + h.height) {
                            isDragging = true;
                            dragTargetBlock = block;
                            
                            // ドラッグ開始位置オフセット
                            // ※2段組で分割されている場合、時間のオフセット計算は
                            // 「ヒットしたセクション」を基準にする必要があるが、
                            // ここでは簡易的にマウス位置をそのまま基準にする
                            
                            if (!isVertical) {
                                dragStartPos.x = pos.x;
                                dragOffset = 0; // 相対移動量のみ使うので0
                                dragCrossOffset = pos.y - h.y;
                            } else {
                                dragStartPos.y = pos.y;
                                dragOffset = 0;
                                dragCrossOffset = pos.x - h.x;
                            }
                            
                            // ドラッグ初期位置 = マウス位置 - ブロック内オフセット
                            dragCurrentPos = { 
                                x: pos.x - (isVertical ? dragCrossOffset : 0), 
                                y: pos.y - (isVertical ? 0 : dragCrossOffset) 
                            };
                            
                            dragOriginalStartMs = new Date(block.startISO).getTime();
                            dragOriginalEndMs = new Date(block.endISO).getTime();
                            dragOriginalRow = block.layoutRow; 
                            
                            canvas.classList.add('dragging');
                            if (e.type === 'touchstart') e.preventDefault(); 
                            return; // ループ抜け
                        }
                    }
                }
            }

            function handleClickInEditMode(e) {
                const pos = getCanvasCoordinates(e);
                for (const block of [...projectBlocks].reverse()) {
                    // 削除ボタン判定
                    if (block.deleteHitBoxes) {
                        for (const d of block.deleteHitBoxes) {
                            if (pos.x >= d.x && pos.x <= d.x + d.width && pos.y >= d.y && pos.y <= d.y + d.height) {
                                if (confirm(`「${block.name}」を本当に削除しますか？`)) {
                                    projectBlocks = projectBlocks.filter(b => b.id !== block.id);
                                    saveToLocalStorage();
                                    drawCanvas();
                                }
                                return;
                            }
                        }
                    }
                    // 本体判定
                    if (block.hitBoxes) {
                        for (const h of block.hitBoxes) {
                            if (pos.x >= h.x && pos.x <= h.x + h.width && pos.y >= h.y && pos.y <= h.y + h.height) {
                                openEditModal(block);
                                return;
                            }
                        }
                    }
                }
            }

            function handleInputMove(e) {
                if (!isDragging || !dragTargetBlock) return;
                e.preventDefault(); 
                const pos = getCanvasCoordinates(e);
                
                let deltaMs = 0;
                // 移動量計算
                if (!isVertical) {
                    const deltaPixel = pos.x - dragStartPos.x;
                    deltaMs = deltaPixel / pxPerMs;
                    dragCurrentPos.x = pos.x; // 横: 追従（実際には描画関数で補正）
                    dragCurrentPos.y = pos.y - dragCrossOffset; 
                } else {
                    const deltaPixel = pos.y - dragStartPos.y;
                    deltaMs = deltaPixel / pxPerMs;
                    dragCurrentPos.y = pos.y;
                    dragCurrentPos.x = pos.x - dragCrossOffset;
                }

                const newStartMs = dragOriginalStartMs + deltaMs;
                const newEndMs = dragOriginalEndMs + deltaMs;
                dragTargetBlock.startISO = new Date(newStartMs).toISOString();
                dragTargetBlock.endISO = new Date(newEndMs).toISOString();
                
                drawCanvas(); 
            }

            function handleInputEnd(e) {
                if (isDragging) {
                    isDragging = false;
                    canvas.classList.remove('dragging');
                    
                    // ドロップ位置の行判定 (中央揃えオフセットを考慮して逆算)
                    // y = PADDING + OFFSET + (row * SIZE)
                    // row = (y - PADDING - OFFSET) / SIZE
                    
                    let dropRow = 0;
                    let targetCoord = 0;
                    
                    // 2段組の場合、マウス座標が「どのセクション領域」にあるか判定し、
                    // セクションのオフセットを引く必要があるが、
                    // 今回は「行番号」はセクションに関わらず 0~N なので、
                    // 単純にローカル座標系での相対位置から算出する。
                    
                    if (!isVertical) {
                        // 横表示: Y座標
                        let relY = dragCurrentPos.y - contentOffsetY;
                        
                        // 2段組の下段にいる場合
                        const lowerStart = PADDING_CROSS + (layoutRowCount * ROW_SIZE) + GAP_2COL;
                        if (isTwoColumn && relY >= lowerStart) {
                            relY -= (lowerStart - PADDING_CROSS); // 上段基準に戻す
                        }
                        targetCoord = relY;
                    } else {
                        // 縦表示: X座標
                        let relX = dragCurrentPos.x - contentOffsetX;
                        const rightStart = PADDING_CROSS + (layoutRowCount * ROW_SIZE) + GAP_2COL;
                        if (isTwoColumn && relX >= rightStart) {
                            relX -= (rightStart - PADDING_CROSS);
                        }
                        targetCoord = relX;
                    }
                    
                    dropRow = Math.round((targetCoord - PADDING_CROSS) / ROW_SIZE);
                    if (dropRow < 0) dropRow = 0;

                    // スワップ処理
                    const targetStart = new Date(dragTargetBlock.startISO).getTime();
                    const targetEnd = new Date(dragTargetBlock.endISO).getTime();

                    const conflictingBlocks = projectBlocks.filter(b => {
                        if (b === dragTargetBlock) return false;
                        if (b.layoutRow !== dropRow) return false;
                        const bStart = new Date(b.startISO).getTime();
                        const bEnd = new Date(b.endISO).getTime();
                        return targetStart < bEnd && targetEnd > bStart;
                    });

                    if (conflictingBlocks.length > 0) {
                        conflictingBlocks.forEach(b => {
                            b.layoutRow = dragOriginalRow;
                        });
                    }

                    dragTargetBlock.layoutRow = dropRow;
                    dragTargetBlock = null;

                    saveToLocalStorage(); 
                    drawCanvas();
                }
            }

            // --- イベントリスナー登録 (既存と同じ) ---
            projectNameEl.addEventListener('click', () => {
                const newName = prompt('新しいプロジェクト名を入力してください:', currentProjectName);
                if (newName && newName.trim() !== '') {
                    currentProjectName = newName.trim();
                    projectNameEl.textContent = currentProjectName;
                    saveToLocalStorage(); 
                }
            });
            document.getElementById('toggle-view-btn').addEventListener('click', (e) => {
                isVertical = !isVertical;
                e.target.disabled = false; 
                drawCanvas();
            });
            document.getElementById('two-column-toggle').addEventListener('change', (e) => {
                isTwoColumn = e.target.checked;
                drawCanvas();
            });
            document.getElementById('toggle-view-btn').disabled = false;
            document.getElementById('two-column-toggle').disabled = false;

            document.getElementById('add-block-btn').addEventListener('click', () => {
                editingBlockId = null; 
                document.getElementById('block-modal-title').textContent = 'ブロック追加';
                document.getElementById('block-edit-form').reset();
                document.getElementById('block-id').value = '';
                const now = new Date();
                const yyyyMMdd = now.toISOString().split('T')[0];
                const hhMM = now.toTimeString().substring(0, 5);
                document.getElementById('block-start-date').value = yyyyMMdd;
                document.getElementById('block-start-time').value = hhMM;
                document.getElementById('block-end-date').value = yyyyMMdd;
                document.getElementById('block-end-time').value = hhMM;
                const blockColorInput = document.getElementById('block-color');
                const colorPicker = document.getElementById('color-picker');
                blockColorInput.value = '#3B82F6';
                 Array.from(colorPicker.children).forEach((child, index) => {
                    child.style.borderColor = (index === 0) ? '#333' : 'transparent';
                });
                showModal('block-edit-modal');
            });
            document.getElementById('edit-mode-btn').addEventListener('click', (e) => {
                isEditMode = !isEditMode;
                const btn = e.currentTarget;
                if (isEditMode) {
                    btn.innerHTML = '<i class="fa-solid fa-check"></i> 編集モード終了';
                    btn.classList.add('btn-primary');
                    btn.classList.remove('btn-secondary');
                    canvas.classList.add('edit-mode-active');
                } else {
                    btn.innerHTML = '<i class="fa-solid fa-pen"></i> 編集モード';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                    canvas.classList.remove('edit-mode-active');
                }
                drawCanvas(); 
            });
            document.getElementById('reset-btn').addEventListener('click', () => {
                if (confirm('プロジェクトをリセットしますか？\n（すべてのブロックが削除されます）')) {
                    projectBlocks = [];
                    saveToLocalStorage();
                    drawCanvas();
                }
            });
            document.getElementById('save-btn').addEventListener('click', () => {
                const user = getUserSession();
                if (!user) {
                    alert('プロジェクトを保存するにはログインが必要です。');
                    sessionStorage.setItem('login_redirect_reason', 'save');
                    window.location.href = 'login.html';
                    return;
                }
                saveProjectData(user.username);
            });
            document.getElementById('export-img-btn').addEventListener('click', () => {
                if (projectBlocks.length === 0) {
                    alert('出力するブロックがありません。');
                    return;
                }
                try {
                    const exportCanvas = document.createElement('canvas');
                    const exportCtx = exportCanvas.getContext('2d');
                    drawTimeline(exportCtx, true); 
                    const dataUrl = exportCanvas.toDataURL('image/png');
                    const now = new Date();
                    const yyyy = now.getFullYear();
                    const MM = String(now.getMonth() + 1).padStart(2, '0');
                    const dd = String(now.getDate()).padStart(2, '0');
                    const HH = String(now.getHours()).padStart(2, '0');
                    const mm = String(now.getMinutes()).padStart(2, '0');
                    const fileName = `${currentProjectName}_${yyyy}${MM}${dd}_${HH}${mm}.png`;
                    const link = document.createElement('a');
                    link.download = fileName;
                    link.href = dataUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } catch (e) {
                    console.error('画像出力エラー:', e);
                    alert('画像の出力に失敗しました。');
                }
            });

            // モーダル設定などは変更なし (省略せず記述)
            setupModalClose('block-edit-modal', '#cancel-block-edit-btn');
            const blockEditForm = document.getElementById('block-edit-form');
            const colors = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', '#64748B'];
            const colorPicker = document.getElementById('color-picker');
            const blockColorInput = document.getElementById('block-color');
            colors.forEach(color => {
                const colorCircle = document.createElement('div');
                colorCircle.style.width = '30px';
                colorCircle.style.height = '30px';
                colorCircle.style.borderRadius = '50%';
                colorCircle.style.backgroundColor = color;
                colorCircle.style.cursor = 'pointer';
                colorCircle.style.border = '3px solid transparent';
                colorCircle.dataset.color = color;
                if (color === blockColorInput.value) {
                    colorCircle.style.borderColor = '#333';
                }
                colorCircle.addEventListener('click', () => {
                    blockColorInput.value = color;
                    Array.from(colorPicker.children).forEach(child => {
                        child.style.borderColor = 'transparent';
                    });
                    colorCircle.style.borderColor = '#333';
                });
                colorPicker.appendChild(colorCircle);
            });
            blockEditForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const name = document.getElementById('block-name').value;
                const startDate = document.getElementById('block-start-date').value;
                const startTime = document.getElementById('block-start-time').value;
                const endDate = document.getElementById('block-end-date').value;
                const endTime = document.getElementById('block-end-time').value;
                const color = document.getElementById('block-color').value;
                if (!name || !startDate || !startTime || !endDate || !endTime) {
                    alert('すべての日時を入力してください。');
                    return;
                }
                const startISO = new Date(`${startDate}T${startTime}`).toISOString();
                const endISO = new Date(`${endDate}T${endTime}`).toISOString();
                if (new Date(endISO) <= new Date(startISO)) {
                    alert('終了日時は開始日時より後に設定してください。');
                    return;
                }
                const blockData = { name, startISO, endISO, color };
                if (editingBlockId) {
                    const index = projectBlocks.findIndex(b => b.id === editingBlockId);
                    if (index !== -1) {
                        projectBlocks[index] = { ...projectBlocks[index], ...blockData };
                    }
                } else {
                    const newBlock = {
                        ...blockData,
                        id: Date.now().toString(),
                        layoutRow: -1
                    };
                    newBlock.layoutRow = findAvailableRow(newBlock);
                    projectBlocks.push(newBlock);
                }
                editingBlockId = null; 
                saveToLocalStorage();
                drawCanvas();
                hideModal('block-edit-modal');
            });

            function openEditModal(block) {
                editingBlockId = block.id; 
                document.getElementById('block-modal-title').textContent = 'ブロック編集';
                document.getElementById('block-id').value = block.id;
                document.getElementById('block-name').value = block.name;
                const start = new Date(block.startISO);
                const end = new Date(block.endISO);
                document.getElementById('block-start-date').value = start.toISOString().split('T')[0];
                document.getElementById('block-start-time').value = start.toTimeString().substring(0, 5);
                document.getElementById('block-end-date').value = end.toISOString().split('T')[0];
                document.getElementById('block-end-time').value = end.toTimeString().substring(0, 5);
                blockColorInput.value = block.color;
                Array.from(colorPicker.children).forEach(child => {
                    child.style.borderColor = (child.dataset.color === block.color) ? '#333' : 'transparent';
                });
                showModal('block-edit-modal');
            }

            canvas.addEventListener('mousedown', handleInputStart);
            canvas.addEventListener('mousemove', handleInputMove);
            canvas.addEventListener('mouseup', handleInputEnd);
            canvas.addEventListener('mouseleave', handleInputEnd);
            canvas.addEventListener('touchstart', handleInputStart, {passive: false});
            canvas.addEventListener('touchmove', handleInputMove, {passive: false});
            canvas.addEventListener('touchend', handleInputEnd);

            const urlParams = new URLSearchParams(window.location.search);
            const loadedCsvData = sessionStorage.getItem('bloske_loaded_csv');
            if (loadedCsvData) {
                currentProjectName = sessionStorage.getItem('bloske_current_project_name') || '読み込みプロジェクト';
                projectBlocks = parseCsvData(loadedCsvData);
                sessionStorage.removeItem('bloske_loaded_csv'); 
                sessionStorage.removeItem('bloske_current_project_name');
            } else if (urlParams.has('restore')) {
                loadFromLocalStorage();
            } else {
                currentProjectName = sessionStorage.getItem('bloske_current_project_name') || '新規プロジェクト';
                sessionStorage.removeItem('bloske_current_project_name');
            }
            projectNameEl.textContent = currentProjectName;
            
            drawCanvas(); 
            window.addEventListener('resize', drawCanvas);

            async function saveProjectData(username) {
                const projectName = projectNameEl.textContent;
                let csvData = "ブロック名,開始日時ISO,終了日時ISO,カラーコード\n"; 
                projectBlocks.forEach(block => {
                    const name = `"${block.name.replace(/"/g, '""')}"`;
                    csvData += `${name},"${block.startISO}","${block.endISO}","${block.color}"\n`;
                });
                if (!confirm(`プロジェクト「${projectName}」を保存しますか？`)) {
                    return;
                }
                try {
                    await callGasApi('saveProject', {
                        username: username,
                        projectName: projectName,
                        csvData: csvData
                    });
                    alert('保存しました。');
                    localStorage.removeItem('bloske_local_project');
                } catch (error) {
                    console.error('保存失敗:', error);
                }
            }
        });
    </script>
</body>
</html>
